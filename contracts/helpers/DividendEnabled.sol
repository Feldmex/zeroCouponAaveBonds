pragma solidity >=0.6.0;
import "../interfaces/ICapitalHandler.sol";
import "../interfaces/IDividend.sol";
import "../interfaces/IYieldToken.sol";
import "../interfaces/IWrapper.sol";
import "../interfaces/IERC20.sol";
import "../libraries/SignedSafeMath.sol";
import "../libraries/SafeMath.sol";
import "./DividendEnabledData.sol";
import "./Ownable.sol";

abstract contract DividendEnabled is IERC20, IDividend, DividendEnabledData {
	using SafeMath for uint256;
	using SignedSafeMath for int256;

	//length of contractBalance arrays
	function length() public view returns (uint) {return contractZCBDividend.length;}

	event DividendDistributed(
		address _claimer,
		address _to,
		uint _amtZCB,
		uint _amtYT
	);

    function transfer(address _to, uint256 _value) public override returns (bool success) {
        require(_value <= internalBalanceOf[msg.sender]);

        claimDividendInternal(msg.sender, msg.sender, false);
        claimDividendInternal(_to, _to, false);

        internalBalanceOf[msg.sender] -= _value;
        internalBalanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    function approve(address _spender, uint256 _value) public override returns (bool success) {
        internalAllowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {
        require(_value <= internalAllowance[_from][msg.sender]);
    	require(_value <= internalBalanceOf[_from]);

        claimDividendInternal(_from, _from, false);
        claimDividendInternal(_to, _to, false);

    	internalBalanceOf[_from] -= _value;
    	internalBalanceOf[_to] += _value;

        internalAllowance[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);

        return true;
    }

    function totalSupply() external view override returns (uint) {
    	return internalTotalSupply;
    }

    function balanceOf(address _owner) external view override returns (uint) {
    	return internalBalanceOf[_owner];
    }

    function allowance(address _owner, address _spender) external view override returns (uint) {
    	return internalAllowance[_owner][_spender];
    }

	//10 ** decimals == the amount of sub units in a whole coin
	uint8 public constant override decimals = 18;

    //-----------------i-m-p-l-e-m-e-n-t-s---y-i-e-l-d----------------

	/*
		@Description: allows token holders to claim their portion of the cashflow
	*/
	function claimDividend(address _to) external override {
		claimDividendInternal(msg.sender, _to, false);
	}

	/*
		@Description: Harvests funds to be paid as dividends

		@return uint asset1: the amount of asset1 that has been credited to this contract
		@return uint asset2: the amount of asset2 that has been credited to this contract
	*/
	function contractClaimDividend() external virtual override;

	//--------y-i-e-l-d---i-m-p-l-e-m-e-n-t-a-t-i-o-n---h-e-l-p-e-r-s-------------------

	/*
		@Description: whenever tokens native to this contract are transfered / minted / burned this function must be called.
			This function distributes dividends generated by _from to _to

		@param address _from: address for which to distribute generated dividends
		@param address _to: address that shall receive all dividends
		@param bool _postpone: if true _from will not be elidgeble for yield generated in the current round
			otherwise user will still be able to claim yield generated in the current round
	*/
	function claimDividendInternal(address _from, address _to, bool _postpone) internal {
		uint mostRecent = lastClaim[_from];
		uint lastIndex = contractZCBDividend.length - 1;	//gas savings
		if (mostRecent >= lastIndex) return;
		uint _balanceOf = internalBalanceOf[_from];	//gas savings
		lastClaim[_from] = lastIndex + (_postpone ? 1 : 0);
		if (_balanceOf == 0) return;

		uint ZCBtoSend;
		uint YTtoSend;
		{
			uint BalanceYieldChange = contractYieldDividend[lastIndex] - contractYieldDividend[mostRecent];
			int BalanceZCBChange = contractZCBDividend[lastIndex] - contractZCBDividend[mostRecent];
			uint nonBalanceNormalYT = wrapper.WrappedAmtToUnitAmt_RoundDown(BalanceYieldChange);
			//YTtoSend = wrapper.WrappedAmtToUnitAmt_RoundDown(BalanceYieldChange);
			ZCBtoSend = uint(int(nonBalanceNormalYT) + BalanceZCBChange).mul(_balanceOf).div(1 ether);
			YTtoSend = nonBalanceNormalYT.mul(_balanceOf).div(1 ether);

		}

		IERC20(ZCBaddress).transfer(_to, ZCBtoSend);
		ZCBdividendOut += ZCBtoSend;

		IYieldToken(YTaddress).transfer_2(_to, YTtoSend, false);
		YTdividendOut += YTtoSend;

		activeTotalSupply = internalTotalSupply;
		emit DividendDistributed(_from, _to, ZCBtoSend, YTtoSend);
	}

	/*
		@Description: get the total amount of dividends claimed by contract claim dividend up to now

		@return uint ZCB: the amount of ZCB dividends up to now
		@return uint YT: the amount of YT dividends up to now
	*//*
	function totalUnitDividends() internal view returns (uint ZCB, uint YT) {
		uint lastIndex = contractZCBDividend.length - 1;
		uint BalanceYield = contractYieldDividend[lastIndex];
		int BalanceZCB = contractZCBDividend[lastIndex];
		YT = wrapper.WrappedAmtToUnitAmt_RoundDown(BalanceYield);
		ZCB = uint(int(YT) + BalanceZCB);
	}*/

	/*
		@Description: add new dividend round

		@param uint ZCBdividend: the amount of ZCB in unit in round dividend
		@param uint YTdividend: the amount of YT in unit in round divided
	*/
	function writeNextDividend(uint ZCBdividend, uint YTdividend) internal {
		uint scaledYield = wrapper.UnitAmtToWrappedAmt_RoundDown(YTdividend);
		/*
			ZCBdividend == scaledYield + balanceBond
			balanceBond == ZCBdividend - scaledYield
		*/
		int balanceBond = int(ZCBdividend) - int(scaledYield);

		uint lastIndex = contractZCBDividend.length - 1;
		uint prevYieldDividend = contractYieldDividend[lastIndex];
		int prevZCBDividend = contractZCBDividend[lastIndex];

		//normalise with activeTotalSupply
		uint _activeTotalSupply = activeTotalSupply;
		if (_activeTotalSupply == 0) {
			//in odd case that there is no active supply all supply is made active
			//this is done by pushing the previous lastValues in the dividend arrays
			//then we push the new values, thus giving those with previously non active
			//LP shares the chance to earn the interest, also avoid div by 0
			contractYieldDividend.push(prevYieldDividend);
			contractZCBDividend.push(prevZCBDividend);
			_activeTotalSupply = internalTotalSupply;
		}

		scaledYield = scaledYield.mul(1 ether).div(_activeTotalSupply);
		balanceBond = balanceBond.mul(1 ether).div(int(_activeTotalSupply));

		contractYieldDividend.push(scaledYield + prevYieldDividend);
		contractZCBDividend.push(balanceBond + prevZCBDividend);

		totalZCBDividend += ZCBdividend;
		totalYTDividend += YTdividend;
	}
}