// SPDX-License-Identifier: MIT
pragma solidity >=0.6.8 <0.7.0;
import "../interfaces/IFixCapitalPool.sol";
import "../interfaces/IDividend.sol";
import "../interfaces/IYieldToken.sol";
import "../interfaces/IWrapper.sol";
import "../interfaces/IERC20.sol";
import "../libraries/SignedSafeMath.sol";
import "../libraries/SafeMath.sol";
import "./DividendEnabledData.sol";
import "./Ownable.sol";

abstract contract DividendEnabled is IERC20, IDividend, DividendEnabledData {
	using SafeMath for uint256;
	using SignedSafeMath for int256;

	//length of contractBalance arrays
	function length() public view returns (uint) {return contractZCBDividend.length;}

	event DividendDistributed(
		address _claimer,
		address _to,
		uint _amtZCB,
		uint _amtYT
	);

    function transfer(address _to, uint256 _value) public override returns (bool success) {
        claimDividendInternal(msg.sender, msg.sender);
        claimDividendInternal(_to, _to);

        internalBalanceOf[msg.sender] = internalBalanceOf[msg.sender].sub(_value);
        internalBalanceOf[_to] = internalBalanceOf[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    function approve(address _spender, uint256 _value) public override returns (bool success) {
        internalAllowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {
        require(_value <= internalAllowance[_from][msg.sender]);

        claimDividendInternal(_from, _from);
        claimDividendInternal(_to, _to);

        internalBalanceOf[_from] = internalBalanceOf[_from].sub(_value);
        internalBalanceOf[_to] = internalBalanceOf[_to].add(_value);

        internalAllowance[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);

        return true;
    }

    function totalSupply() external view override returns (uint) {
    	return internalTotalSupply;
    }

    function balanceOf(address _owner) external view override returns (uint) {
    	return internalBalanceOf[_owner];
    }

    function allowance(address _owner, address _spender) external view override returns (uint) {
    	return internalAllowance[_owner][_spender];
    }

	//10 ** decimals == the amount of sub units in a whole coin
	uint8 public constant override decimals = 18;

	//-----------------i-n-e-l-i-g-i-b-l-e---L-P---t-o-k-e-n-s---a-r-e---t-r-a-n-s-f-e-r-r-a-b-l-e-------------

    function transferIneligible(address _to, uint256 _value) external returns (bool success) {
        claimDividendInternal(msg.sender, msg.sender);
        claimDividendInternal(_to, _to);

        ineligibleBalanceOf[msg.sender] = ineligibleBalanceOf[msg.sender].sub(_value);
        ineligibleBalanceOf[_to] = ineligibleBalanceOf[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    function transferIneligibleFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        require(_value <= internalAllowance[_from][msg.sender]);

        claimDividendInternal(_from, _from);
        claimDividendInternal(_to, _to);

        ineligibleBalanceOf[_from] = ineligibleBalanceOf[_from].sub(_value);
        ineligibleBalanceOf[_to] = ineligibleBalanceOf[_to].add(_value);

        internalAllowance[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);

        return true;
    }

    //-----------------i-m-p-l-e-m-e-n-t-s---y-i-e-l-d----------------

	/*
		@Description: allows token holders to claim their portion of the cashflow
	*/
	function claimDividend(address _to) external override {
		claimDividendInternal(msg.sender, _to);
	}

	/*
		@Description: Harvests funds to be paid as dividends

		@return uint asset1: the amount of asset1 that has been credited to this contract
		@return uint asset2: the amount of asset2 that has been credited to this contract
	*/
	function contractClaimDividend() external virtual override;

	//--------y-i-e-l-d---i-m-p-l-e-m-e-n-t-a-t-i-o-n---h-e-l-p-e-r-s-------------------

	/*
		@Description: whenever tokens native to this contract are transfered / minted / burned this function must be called.
			This function distributes dividends generated by _from to _to

		@param address _from: address for which to distribute generated dividends
		@param address _to: address that shall receive all dividends
		@param bool _postpone: if true _from will not be elidgeble for yield generated in the current round
			otherwise user will still be able to claim yield generated in the current round
	*/
	function claimDividendInternal(address _from, address _to) internal {
		uint mostRecent = lastClaim[_from];
		uint lastIndex = contractZCBDividend.length - 1;	//gas savings
		if (mostRecent >= lastIndex) return;
		uint _balanceOf = internalBalanceOf[_from];	//gas savings
		lastClaim[_from] = lastIndex;
		if (_balanceOf == 0) return;

		uint ZCBtoSend;
		uint YTtoSend;
		uint lastYieldDividend = contractYieldDividend[lastIndex];
		int lastZCBDividend = contractZCBDividend[lastIndex];
		{
			uint BalanceYieldChange = lastYieldDividend - contractYieldDividend[mostRecent];
			int BalanceZCBChange = lastZCBDividend - contractZCBDividend[mostRecent];
			uint unitAmountYield = wrapper.WrappedAmtToUnitAmt_RoundDown(BalanceYieldChange);
			ZCBtoSend = uint(int(unitAmountYield) + BalanceZCBChange).mul(_balanceOf).div(1 ether);
			YTtoSend = unitAmountYield.mul(_balanceOf).div(1 ether);
		}
		uint ineligibleBal = ineligibleBalanceOf[_from];
		if (ineligibleBal != 0) {
			if (mostRecent+1 < lastIndex) {
				uint BalanceYieldChange = lastYieldDividend - contractYieldDividend[mostRecent+1];
				int BalanceZCBChange = lastZCBDividend - contractZCBDividend[mostRecent+1];
				uint unitAmountYield = wrapper.WrappedAmtToUnitAmt_RoundDown(BalanceYieldChange);
				ZCBtoSend += uint(int(unitAmountYield) + BalanceZCBChange).mul(_balanceOf).div(1 ether);
				YTtoSend += unitAmountYield.mul(_balanceOf).div(1 ether);
			}
			internalBalanceOf[_from] += ineligibleBal;
			ineligibleBalanceOf[_from] = 0;
		}

		IERC20(ZCBaddress).transfer(_to, ZCBtoSend);
		ZCBdividendOut += ZCBtoSend;

		IYieldToken(YTaddress).transfer_2(_to, YTtoSend, false);
		YTdividendOut += YTtoSend;

		activeTotalSupply = internalTotalSupply;
		emit DividendDistributed(_from, _to, ZCBtoSend, YTtoSend);
	}

}