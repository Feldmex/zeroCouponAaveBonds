pragma solidity >=0.6.0;
import "../interfaces/ICapitalHandler.sol";
import "../interfaces/IYieldEnabled.sol";
import "../interfaces/IYieldToken.sol";
import "../interfaces/IWrapper.sol";
import "../interfaces/IERC20.sol";
import "../libraries/SignedSafeMath.sol";
import "../libraries/SafeMath.sol";
import "./Ownable.sol";

abstract contract doubleAssetYieldEnabledToken is IERC20, IYieldEnabled {
	using SafeMath for uint256;
	using SignedSafeMath for int256;

	
	address public ZCBaddress;
	address public YTaddress;

	IWrapper wrapper;


	//the amount of LP shares that are eldigeble to claim interest generated by their funds
	uint public activeTotalSupply;

	uint public lastWithdraw;
	//total amount of smallest denomination units of coin in this smart contract
	uint public override totalSupply;
	//10 ** decimals == the amount of sub units in a whole coin
	uint8 public override decimals = 18;
	//each user's balance of coins
	mapping(address => uint) public override balanceOf;
	//the amount of funds each address has allowed other addresses to spend on the first address's behalf
	//holderOfFunds => spender => amountOfFundsAllowed
	mapping(address => mapping(address => uint)) public override allowance;


	event DividendDistributed(
		address _claimer,
		address _to,
		uint _amtZCB,
		uint _amtYT
	);

	/*
		@Description: Assigns inital values and credits the owner of this contract with all coins

		@param address _ZCBaddress: the address of the ERC0 contract of asset1
		@param address _YTaddress: the address of the ERC20 contract of asset2
	*/
	function init(address _ZCBaddress, address _YTaddress) internal {
		ZCBaddress = _ZCBaddress;
		YTaddress = _YTaddress;
		contractZCBDividend.push(0);
		contractYieldDividend.push(0);
	}

    function transfer(address _to, uint256 _value) public override returns (bool success) {
        require(_value <= balanceOf[msg.sender]);

        claimDividendInternal(msg.sender, msg.sender, false);
        claimDividendInternal(_to, _to, false);

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    function approve(address _spender, uint256 _value) public override returns (bool success) {
        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
    	require(_value <= balanceOf[_from]);

        claimDividendInternal(_from, _from, false);
        claimDividendInternal(_to, _to, false);

    	balanceOf[_from] -= _value;
    	balanceOf[_to] += _value;

        allowance[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);

        return true;
    }

    //-----------------i-m-p-l-e-m-e-n-t-s---y-i-e-l-d----------------

	/*
		@Description: allows token holders to claim their portion of the cashflow
	*/
	function claimDividend(address _to) external override {
		claimDividendInternal(msg.sender, _to, false);
	}

	/*
		@Description: Harvests funds to be paid as dividends

		@return uint asset1: the amount of asset1 that has been credited to this contract
		@return uint asset2: the amount of asset2 that has been credited to this contract
	*/
	function contractClaimDividend() external virtual override;

	//--------y-i-e-l-d---i-m-p-l-e-m-e-n-t-a-t-i-o-n---h-e-l-p-e-r-s-------------------

	/*
		@Description: whenever tokens native to this contract are transfered / minted / burned this function must be called.
			This function distributes dividends generated by _from to _to

		@param address _from: address for which to distribute generated dividends
		@param address _to: address that shall receive all dividends
		@param bool _postpone: if true _from will not be elidgeble for yield generated in the current round
			otherwise user will still be able to claim yield generated in the current round
	*/
	function claimDividendInternal(address _from, address _to, bool _postpone) internal {
		uint mostRecent = lastClaim[_from];
		uint lastIndex = contractZCBDividend.length - 1;	//gas savings
		if (mostRecent >= lastIndex) return;
		uint _balanceOf = balanceOf[_from];	//gas savings
		lastClaim[_from] = lastIndex + (_postpone ? 1 : 0);
		if (_balanceOf == 0) return;

		uint ZCBtoSend;
		uint YTtoSend;
		{
			uint BalanceYieldChange = contractYieldDividend[lastIndex] - contractYieldDividend[mostRecent];
			int BalanceZCBChange = contractZCBDividend[lastIndex] - contractZCBDividend[mostRecent];
			uint nonBalanceNormalYT = wrapper.WrappedAmtToUnitAmt_RoundDown(BalanceYieldChange);
			//YTtoSend = wrapper.WrappedAmtToUnitAmt_RoundDown(BalanceYieldChange);
			ZCBtoSend = uint(int(nonBalanceNormalYT) + BalanceZCBChange).mul(_balanceOf).div(1 ether);
			YTtoSend = nonBalanceNormalYT.mul(_balanceOf).div(1 ether);

		}

		IERC20(ZCBaddress).transfer(_to, ZCBtoSend);
		ZCBdividendOut += ZCBtoSend;

		IYieldToken(YTaddress).transfer_2(_to, YTtoSend, false);
		YTdividendOut += YTtoSend;

		activeTotalSupply = totalSupply;
		emit DividendDistributed(_from, _to, ZCBtoSend, YTtoSend);
	}

	/*
		@Description: get the total amount of dividends claimed by contract claim dividend up to now

		@return uint ZCB: the amount of ZCB dividends up to now
		@return uint YT: the amount of YT dividends up to now
	*//*
	function totalUnitDividends() internal view returns (uint ZCB, uint YT) {
		uint lastIndex = contractZCBDividend.length - 1;
		uint BalanceYield = contractYieldDividend[lastIndex];
		int BalanceZCB = contractZCBDividend[lastIndex];
		YT = wrapper.WrappedAmtToUnitAmt_RoundDown(BalanceYield);
		ZCB = uint(int(YT) + BalanceZCB);
	}*/

	/*
		@Description: add new dividend round

		@param uint ZCBdividend: the amount of ZCB in unit in round dividend
		@param uint YTdividend: the amount of YT in unit in round divided
	*/
	function writeNextDividend(uint ZCBdividend, uint YTdividend) internal {
		uint scaledYield = wrapper.UnitAmtToWrappedAmt_RoundDown(YTdividend);
		/*
			ZCBdividend == scaledYield + balanceBond
			balanceBond == ZCBdividend - scaledYield
		*/
		int balanceBond = int(ZCBdividend) - int(scaledYield);

		uint lastIndex = contractZCBDividend.length - 1;
		uint prevYieldDividend = contractYieldDividend[lastIndex];
		int prevZCBDividend = contractZCBDividend[lastIndex];

		//normalise with activeTotalSupply
		uint _activeTotalSupply = activeTotalSupply;
		if (_activeTotalSupply == 0) {
			//in odd case that there is no active supply all supply is made active
			//this is done by pushing the previous lastValues in the dividend arrays
			//then we push the new values, thus giving those with previously non active
			//LP shares the chance to earn the interest, also avoid div by 0
			contractYieldDividend.push(prevYieldDividend);
			contractZCBDividend.push(prevZCBDividend);
			_activeTotalSupply = totalSupply;
		}

		scaledYield = scaledYield.mul(1 ether).div(_activeTotalSupply);
		balanceBond = balanceBond.mul(1 ether).div(int(_activeTotalSupply));

		contractYieldDividend.push(scaledYield + prevYieldDividend);
		contractZCBDividend.push(balanceBond + prevZCBDividend);

		totalZCBDividend += ZCBdividend;
		totalYTDividend += YTdividend;
	}

    /*
		every time lastWithdraw is updated another value is pushed to contractBalanceAsset1 as contractBalanceAsset2
		thus the length of contractBalanceAsset1 and contractBalanceAsset2 are always the same
		lastClaim represents the last index of the contractBalance arrays for each address at the most recent time that claimDividendInternal(said address) was called
	*/
	//lastClaim represents the last index of the contractBalance arrays for each address at the most recent time that claimDividendInternal(said address) was called
	mapping(address => uint) lastClaim;
	//U dividends (unit amount) + ZCBdividends *may be negative*
	int[] public contractZCBDividend;
	//increase in wrapped amount of balanceYield
	uint[] public contractYieldDividend;

	//most recent value in non supply normalized dividend integrals
	uint internal totalZCBDividend;
	uint internal totalYTDividend;
	//the total amount of dividends claimed from this contract
	uint internal ZCBdividendOut;
	uint internal YTdividendOut;

	//length of contractBalance arrays
	function length() public view returns (uint) {return contractZCBDividend.length;}
}